1)Every browser has javascript engine running in the background which runs the javascript code.
FireFox - spiderMonkey
Chrome - v8
Thats why the code can be written in the developer tools console area
JavaScript can execute not only in the browser, but also on the server, or actually on any device that has a special program called the JavaScript engine.
The browser has an embedded engine sometimes called a “JavaScript virtual machine”.

Every browser will have javascript engine which will do the following-

The engine (embedded if it’s a browser) reads (“parses”) the script.
Then it converts (“compiles”) the script to the machine language.
And then the machine code runs, pretty fast.

2)there are some web development servers available like Live Server which actually has some extra features like auto reload on changes etc.
http://127.0.0.1:5500/index.html
here the url indicates from where the pages are served from.

3)The reasons for loading the <scripts> in the body tag is that -
Reason 1 - If you load in the head tag, then the problem is that if the script takes lot of time to load then the content of the body tag will not be loaded and user might experience some delay or may be whitepage while the browser is busy parsing/executing the javascript code in scripts etc.

Reason 2 - If you have scripts at the head where the javascript code in that script will have to talk to the elements in the HTML. In that case the elements should be loaded only then the script has to be applied kinda.

However, some 3rd party script should be run in the head tag itself 

4)Run the index.html in the browser and see "Hello world" and the same code in the terminal with node index.js then also you see "Hello world" because the browser v8 engine is integrated with node.

5)In javascript there is no separate floating point and integer or number. All the numbers are numbers like 1.02 and 1.99999 or 133232 or 1 is typeof number

6) Console guys
var some = undefined
typeof(some)
"undefined"

var some = null
typeof(some)
"object"

7)the values in the array need not be same type. var arr = ["hi", "sam", 3 , "phew"]

var p = { name : "anna", age : 26}
typeof(p)
"object"

var someArr = [1,2,"some","pl"]
typeof(someArr)
"object"

8)Procedure oriented programming will have many functions and many variables all together which calls each other and dependent of each other with messy approach like spagheti.
Object oriented approach will group the respective functions and variables in a Object. If you have car object then only those data related to car will be residing in it.
This approach is Object Oriented programming.This is called ENCAPSULATION.

9)You have a DVD player with full complexity inside and outside you have fewer buttons to interact with Likewise we can make our object have all complex logic hidden exposing only simple functions and variables for the outsidee world. Make the complex functions and variables private within them to abstract it. By doing this one can give a simple interface

10)Inheritance as you know helps us to remove redundant code. You need not write code in multiple places instead choose Inheritance

11) In ES6, a new feature is like -

var obj = {
    radius : radius,
    border  : 1
}

or

var obj = {
    radius,
    border  : 1
}

Here key and value are both same, so you can directly use radius

12)The keyword new is very special. Whenever used it creates a new empty objec copy and then add properties and functions to it and then returns it. Without this if you invoke the object, then the this will point to global window object. By using new, it makes it point to the guy who called it.

Example: var some = new Circle(1)
Example: var phew = Circle(1)
So the new plays a very important role in this ;)

13)Every object has a constructor property in it.
A string can be created like "some" or " " or new String("some")
A number can be created like 1, 2 or new Number(4)
A function can be created like function some(){} or like 
new Function('args',`this.draw = function(){console.log("hi")`)

14)Every function is a object. 

15)ECMAScript 5 (ES5) appeared. It added new features to the language and modified some of the existing ones. To keep the old code working, most modifications are off by default. You need to explicitly enable them with a special directive: "use strict".

The directive looks like a string: "use strict" or 'use strict'. When it is located at the top of a script, the whole script works the “modern” way. The "use strict" directive switches the engine to the “modern” mode, changing the behavior of some built-in features. We’ll see the details later in the tutorial.Looking ahead, let’s just note that "use strict" can be put at the start of most kinds of functions instead of the whole script. Doing that enables strict mode in that function only. But usually, people use it for the whole script.

=>    // note: no "use strict" in this example

    num = 5; // the variable "num" is created if it didn't exist

    console.log(num); // 5

=>   "use strict";

num = 5; // error: num is not defined

16)let let = 5; // can't name a variable "let", error!
let var = 5; // can't name a variable "var", error!
let return = 5; // also can't name it "return", error!

17)In JavaScript, there are 3 types of quotes.

Double quotes: "Hello".
Single quotes: 'Hello'.
Backticks: `Hello ${name}`.

18)The operator ++/-- before or after the variable matters. ++counter to counter++

Let’s clarify. As we know, all operators return a value. Increment/decrement is no exception. The prefix form returns the new value while the postfix form returns the old value (prior to increment/decrement).

let counter = 1;
let a = ++counter; // (*)

console.log(a); // 2

let counter = 1;
let a = counter++; // (*) changed ++counter to counter++

console.log(a); // 1

If the result of increment/decrement is not used, there is no difference in which form to use:
let counter = 0;
counter++;
++counter;
console.log( counter ); // 2, the lines above did the same

If we’d like to increase a value and immediately use the result of the operator, we need the prefix form:
let counter = 0;
console.log( ++counter ); // 1

If we’d like to increment a value but use its previous value, we need the postfix form:
let counter = 0;
console.log( counter++ ); // 0

let counter = 1;
alert( 2 * ++counter ); // 4

let counter = 1;
alert( 2 * counter++ ); // 2, because counter++ returns the "old" value

19)String comparison
To see whether a string is greater than another, JavaScript uses the so-called “dictionary” or “lexicographical” order.
In other words, strings are compared letter-by-letter.

http://javascript.info/comparison

20)Interaction modals - alert, popup and confirm

let ans = popup("how are you", '') //IE
let ans = popup("how are you") //General
alert("The response is ", ans)

let yesOrNo = confirm("Are you insane?")
alert(yesOrNo)
//OK click returns true, Cancel returns false

21)Normally, a loop exits when its condition becomes falsy.
But we can force the exit at any time using the special break directive.

The continue directive is a “lighter version” of break. It doesn’t stop the whole loop. Instead, it stops the current iteration and forces the loop to start a new one (if the condition allows).

22)For Switch If there is no break then the execution continues with the next case without any checks.

23)A function with an empty return or without it returns undefined
function doNothing() { /* empty */ }

alert( doNothing() === undefined ); // true

function doNothing() {
  return;
}

alert( doNothing() === undefined ); // true

24)In JavaScript, a default parameter is evaluated every time the function is called without the respective parameter. In the example above, anotherFunction() is called every time showMessage() is called without the text parameter.
 
function showMessage(from, text = anotherFunction()) {
  // anotherFunction() only executed if no text given
  // its result becomes the value of text
}

25)A function with an empty return or without it returns undefined
If a function does not return a value, it is the same as if it returns undefined:

You can check if like this also
function showMovie(age) {
  if ( !checkAge(age) ) {
    return;
  }

  alert( "Showing you the movie" ); // (*)
  // ...
}

26)Never add a newline between return and the value like 
return
 (some + long + expression + or + whatever * f(a) + f(b))

That doesn’t work, because JavaScript assumes a semicolon after return. That’ll work the same as:
return;
 (some + long + expression + or + whatever * f(a) + f(b))
 So, it effectively becomes an empty return.

If we want the returned expression to wrap across multiple lines, we should start it at the same line as return. Or at least put the opening parentheses there as follows:
return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )

  function some() {
	var a = 10;
	function a(){
		console.log("hi");
	}
	console.log(a())
}

27)When we use modern features of the language, some engines may fail to support such code. Just as said, not all features are implemented everywhere.Babel is a transpiler. It rewrites modern JavaScript code into the previous standard.

Actually, there are two parts in Babel:

First, the transpiler program, which rewrites the code. The developer runs it on their own computer. It rewrites the code into the older standard. And then the code is delivered to the website for users. Modern project build systems like webpack provide means to run transpiler automatically on every code change, so that very easy to integrate into development process.

Second, the polyfill.

New language features may include new built-in functions and syntax constructs. The transpiler rewrites the code, transforming syntax constructs into older ones. But as for new built-in functions, we need to implement them. JavaScript is a highly dynamic language, scripts may add/modify any functions, so that they behave according to the modern standard.

A script that updates/adds new functions is called “polyfill”. It “fills in” the gap and adds missing implementations.

Two interesting polyfills are:

core js that supports a lot, allows to include only needed features.
polyfill.io service that provides a script with polyfills, depending on the features and user’s browser.

28)    @HostListener("window:onbeforeunload",["$event"])
for event of closing the browser

29)window or global object
In a browser, global functions and variables declared with var (not let/const!) become the property of the global object:

var gVar = 5;
alert(window.gVar); // 5 (became a property of the global object)

If we used let instead, such thing wouldn’t happen:

let gLet = 5;
alert(window.gLet); // undefined (doesn't become a property of the global object)

If a value is so important that you’d like to make it available globally, write it directly as a property:

// make current user information global, to let all scripts access it
window.currentUser = {
  name: "John"
};

// somewhere else in code
alert(currentUser.name);  // John

// or, if we have a local variable with the name "currentUser"
// get it from window explicitly (safe!)
alert(window.currentUser.name); // John

30) "1" + 2 + 3 - 5 // 118

arr = [1,2,3,4]
arr.length = 0 //arr is deleted

31) for(var i=0; i<=5; i++){
  setTimeout(() => {
    console.log(i)
  })
}
// 5 5 5 5 5

32) for(let i=0; i<=5; i++){
  setTimeout(() => {
    console.log(i)
  })
}

33)The DOMContentLoaded event fires when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading.
vs onload or domload

34)rem px and % and calc()

35) Prototypes - check example for details
Every JavaScript object has an internal property called [[Prototype]]. If you look up a property via obj.propName or obj['propName'] and the object does not have such a property - which can be checked via obj.hasOwnProperty('propName') - the runtime looks up the property in the object referenced by [[Prototype]] instead. If the prototype-object also doesn't have such a property, its prototype is checked in turn, thus walking the original object's prototype-chain until a match is found or its end is reached.

Some JavaScript implementations allow direct access to the [[Prototype]] property, eg via a non-standard property named __proto__. In general, it's only possible to set an object's prototype during object creation: If you create a new object via new Func(), the object's [[Prototype]] property will be set to the object referenced by Func.prototype.
  
The ideal way to create a prototype is by calling new. But there are ways which are not good or not recommended like __proto__

36)Difference between __proto__ and prototype - 
__proto__ is the actual object that is used in the lookup chain to resolve methods, etc. prototype is the object that is used to build __proto__ when you create an object with new:
( new Foo ).__proto__ === Foo.prototype;
( new Foo ).prototype === undefined;

So prototype is not available on the instances themselves (or other objects), but only on the constructor functions.
prototype is only available on functions since they are derived from Function, Function, and Object but in anything else it is not. However, __proto__ is available everywhere.
15)Here, /path/to/script.js is an absolute path to the script from the site root. One can also provide a relative path from the current page. For instance, src="script.js" would mean a file "script.js" in the current folder.

16)A single <script> tag can’t have both the src attribute and code inside.
<script src="file.js">
  alert(1); // the content is ignored, because src is set
</script>

17)Nested comments are not supported! - /**/

18)ECMAScript 5 (ES5) appeared. It added new features to the language and modified some of the existing ones. To keep the old code working, most such modifications are off by default. You need to explicitly enable them with a special directive: "use strict".
let’s note that "use strict" can be put at the beginning of the function body instead of the whole script. Doing that enables strict mode in that function only. But usually, people use it for the whole script.

19)ECMAScript 5 (ES5)  added new features to the language and modified some of the existing ones. To keep the old code working, most such modifications are off by default
The "use strict" directive switches the engine to the “modern” mode, changing the behavior of some built-in features. 

20)Variables named apple and AppLE are two different variables.
Non-Latin letters are allowed, but not recommended

21)Any math which combines number with any alphabet results Non A Number NaN
alert( "not a number" / 2 ); // NaN, such division is erroneous

22)Backticks are “extended functionality” quotes. They allow us to embed variables and expressions into a string by wrapping them in alert( `Hello, ${name}!` ); // Hello, John!

23)The result of typeof null is "object". That’s wrong. It is an officially recognized error in typeof, kept for compatibility. Of course, null is not an object. It is a special value with a separate type of its own. So, again, this is an error in the language.

24)Numeric conversion happens in mathematical functions and expressions automatically.
alert( "6" / "2" ); // 3

25)Almost all mathematical operations convert values to numbers. A notable exception is addition +. If one of the added values is a string, the other one is also converted to a string.

26)The unary plus or, in other words, the plus operator + applied to a single value, doesn’t do anything to numbers. But if the operand is not a number, the unary plus converts it into a number.
+2 //2
+"2" //2
+"some" //NaN
+null //0

27)Exponentiation **
The exponentiation operator ** is a recent addition to the language.
For a natural number b, the result of a ** b is a multiplied by itself b times.
alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2)
alert( 2 ** 3 ); // 8  (2 * 2 * 2)

28)A double NOT !! is sometimes used for converting a value to boolean type:
console.log( !!"non-empty string" ); // true
console.log( !!null ); // false
