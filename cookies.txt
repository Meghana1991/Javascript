1) Cookies are usually set by a server using response Set-Cookie HTTP-header. Then the browser automatically adds them to (almost) every request to the same domain using Cookie HTTP-header.

One of the most widespread use cases is authentication:

Upon sign in, the server uses Set-Cookie HTTP-header in the response to set a cookie with a unique “session identifier”.
Next time when the request is set to the same domain, the browser sends the cookie over the net using Cookie HTTP-header.
So the server knows who made the request.
We can also access cookies from the browser, using document.cookie property.

2)Reading Cookie - alert( document.cookie ); // cookie1=value1; cookie2=value2;...

3)Setting Cookie - document.cookie = "user=John"; // update only cookie named 'user'

4)The name=value pair, after encodeURIComponent, should not exceed 4kb. So we can’t store anything huge in a cookie.

The total number of cookies per domain is limited to around 20+, the exact limit depends on a browser.

5)Cookies have several options - 
document.cookie = "user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT"

// make the cookie accessible on any subdomain *.site.com:
document.cookie = "user=John; domain=site.com"

6)secure
The cookie should be transferred only over HTTPS.

By default, if we set a cookie at http://site.com, then it also appears at https://site.com and vice versa.

That is, cookies are domain-based, they do not distinguish between the protocols.

With this option, if a cookie is set by https://site.com, then it doesn’t appear when the same site is accessed by HTTP, as http://site.com. So if a cookie has sensitive content that should never be sent over unencrypted HTTP, then the flag is the right thing.

// assuming we're on https:// now
// set the cookie secure (only accessible if over HTTPS)
document.cookie = "user=John; secure";

7)XSRF Token-
Imagine, you are logged into the site bank.com. That is: you have an authentication cookie from that site. Your browser sends it to bank.com with every request, so that it recognizes you and performs all sensitive financial operations.

Now, while browsing the web in another window, you accidentally come to another site evil.com. That site has JavaScript code that submits a form <form action="https://bank.com/pay"> to bank.com with fields that initiate a transaction to the hacker’s account.

The browser sends cookies every time you visit the site bank.com, even if the form was submitted from evil.com. So the bank recognizes you and actually performs the payment.

That’s called a “Cross-Site Request Forgery” (in short, XSRF) attack.

Real banks are protected from it of course. All forms generated by bank.com have a special field, so called “XSRF protection token”, that an evil page can’t generate or extract from a remote page (it can submit a form there, but can’t get the data back). And the site bank.com checks for such token in every form it receives.

But such protection takes time to implement: we need to ensure that every form has the token field, and we must also check all requests.

8)samesite - That’s another security attribute samesite. It’s designed to protect from so-called XSRF (cross-site request forgery) attacks.

samesite=strict (same as samesite without value)

The cookie samesite option provides another way to protect from such attacks, that (in theory) should not require “xsrf protection tokens”.

A cookie with samesite=strict is never sent if the user comes from outside the same site.

In other words, whether a user follows a link from their mail or submits a form from evil.com, or does any operation that originates from another domain, the cookie is not sent.

If authentication cookies have samesite option, then XSRF attack has no chances to succeed, because a submission from evil.com comes without cookies. So bank.com will not recognize the user and will not proceed with the payment.The protection is quite reliable. Only operations that come from bank.com will send the samesite cookie, e.g. a form submission from another page at bank.com.

8)LocalStorage - Web storage objects localStorage and sessionStorage allow to save key/value pairs in the browser.

What’s interesting about them is that the data survives a page refresh (for sessionStorage) and even a full browser restart (for localStorage). 

-localStorage.setItem('test', 1);
-alert( localStorage.getItem('test') ); // 1
-delete localStorage.test;

Loop Over - 
for(let i=0; i<localStorage.length; i++) {
  let key = localStorage.key(i);
  alert(`${key}: ${localStorage.getItem(key)}`);
}

9)localStorage	
Shared between all tabs and windows with the same origin	
Survives browser restart	

sessionStorage
Survives page refresh (but not tab close)
Visible within a browser tab, including iframes from the same origin

10)IndexedDB - IndexedDB is a built-in database, much more powerful than localStorage.
Key/value storage: value can be (almost) anything, multiple key types.
Supports transactions for reliability.
Supports key range queries, indexes.
Can store much more data than localStorage.

That power is usually excessive for traditional client-server apps. IndexedDB is intended for offline apps, to be combined with ServiceWorkers and other technologies.

IndexedDB has a built-in mechanism of “schema versioning”, absent in server-side databases.

Unlike server-side databases, IndexedDB is client-side, the data is stored in the browser, so we, developers, don’t have direct access to it. But when we publish a new version of our app, we may need to update the database.

https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB